# 7.02学习笔记

## JAVA基础

### 类
1. 类所定义的对象叫做成员变量。操作数据的代码叫做成员方法，方法定义怎么样使用成员变量。
2. 类的用途是封装复杂性，所以类的内部有隐藏实现复杂性的机制。有两种访问方式，类的公有接口代表外部的用户可以使用的东西。私有的方法数据只能通过该类的成员代码来访问。
3. this关键字的作用:一是表示对隐式参数的引用，一是调用类中的其他构造方法。

### 继承
1. 继承是子类自动获取父类的数据和方法的机制，这是类之间的一种关系。在定义和实现 一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的 内容作为自己的内容，并加入若干新的内容。JAVA中使用extends实现继承。
2. super关键字的作用:一是调用父类的构造方法， 一是调用父类的方法。
3. 可以把子类的对象赋给父类变量： People p = new Student("Bob","0002","2006137129");
4. JAVA不支持多继承，Java 对于多继承大部分功能的实现是通过接口机制来完成的。

### 接口
1. 接口是 Java 实现多继承的一种机制，一个类可以实现一个或多个接口。接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些 方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为。简单的说接口不 是类，但是定义了一组对类的要求，实现接口的某些类要与接口一致。
2. JAVA中使用关键字interface来定义接口
3. 让类实现一个接口需要使用关键字implements，然后在类中实现接口所定义的方法。
4. Java中接口不是类，不能使用new实例化接口。但是不过虽然不能通过new 构造接口对象，但是还是可以声明接口变量。并且只要类实现了接口，就可以在任何需要该接口的地方使用这个接口的对象。
5. 可以将一个接口变量转换为对某个类的对象的引用，不过此时要进行强制转换， 并且不一定能够完成，情况和从父类引用到子类引用的转换是一样的。例如： Student s = (Student) com;

### 异常
1. 在java中一个异常对象总是Throwable的子类的实例。在Java程序设计中，我们主要关注于Exception的这个分支体系。Exception 中一类是从
RuntimeException 衍生出来的子类，以及不是从它衍生出来的其他异常类。
2. 创建自己的异 常类，创建自己的异常只需要继承 Exception 类或 Exception 的子类就可以了。
3. 在程序中如果碰到了异常的情况，可以有两种方法来处理这个异常，一种是有方法本身 捕获这个异常并进行相应的处理，使用 try…catch 结构；另一种是将这个异常从方法中抛出，使用 throws 以及 throw 关键字。

### 指针
1. 尽管在 Java 中没有显式的使用指针并且也不允许程序员使用指针，而实际上对象的访问就是使用指针来实现的。
2. 如果我们希望判断两个对象 引用是否一致时可以覆盖继承自 Object 类的 equals 方法来实现。

## 数据结构与算法

### 数据基本概念
1. 数据的逻辑结构按照数据元素之间相互关系的特性来分，可以分为四种结构：集合、线性结构、树形结构和图形结构。线性表、栈、队列属于线性结构，树和图属于非线性结构。
2. 数据的逻辑结构可以采用两种方法来描述：二元组、图形。
3. 这表明该结构只考虑数据元素而不考虑它们之 间的关系。我们把具有这种特点的数据结构称为集合结构。
4. 这种数据结构的特点是数据元素之间是 1 对 1 的联系，即线性关系，我们把具有此种特点的数据结构称为线性结构。
5. 这种数据结构的特点是数据元素之间 是 1 对N的联系，我们把具有此种特点的数据结构称为树结构。
6. 这种数据结构的特点是数据元素之间是M对N的联系，我们把具有此种特 点的数据结构称为图结构。
7. 顺序存储结构的特点是：数据元素的存储对应于一块连续的存储空间，数据元素之间的前驱和后续关系通过数据元素在存储器中的相对位置来反映。
8. 链式存储结构的特点是：数据元素的存储对应的是不连续的存储空间，每个存储节点对应一个需要存储的数据元素。元素之间的逻辑关系通过存储节点之间的链接关系反映出来。

### 算法的基本概念
1. 算法（algorithm）是指令的集合，是为解决特定问题而规定的一系列操作。它是明确定义的可计算过程，以一个数据集合作为输入，并产生一个数据集合作为输出。
2. 算法的五个特性：
    1. 输入：一个算法应以待解决的问题的信息作为输入。
    2. 输出：输入对应指令集处理后得到的信息。
    3. 可行性：算法是可行的，即算法中的每一条指令都是可以实现的，均能在有限的时 间内完成。
    4. 有穷性：算法执行的指令个数是有限的，每个指令又是在有限时间内完成的，因此 整个算法也是在有限时间内可以结束的。
    5. 确定性：算法对于特定的合法输入，其对应的输出是唯一的。即当算法从一个特定 输入开始，多次执行同一指令集结果总是相同的。
3. 时间复杂度：一旦去掉表示算法运行时间中的低阶项和首项常数，就称我们是在度量算法的渐进时间复杂度（asymptotic complexity），简称时间复杂度。
    1. Ο符号：也就是说Ο符号提供了一个运行时间的上界。令 T(n)和 f(n)是非负函数，如果存在一个非负整数N以及一个常数 c>0，使得： ∀ n ≥ N,T(n) ≤ cf(n)则 T(n) = Ο(f(n))。
    2. Ω符号: Ω符号在运行时间的常数因子范围内给出了时间复杂度的下界。Ω符号可以解释为：如果输入大于等于某个阈值N，算法的运行时间下限是 f(n)的 c 倍，其中 c 是一个正常数，则称算法的时间复杂度是Ω(f(n))的。Ω的形式定义与Ο符号对称。
    3. θ符号:θ给出了算法时间复杂度的精确阶。Θ符号可以解释为：如果输入大于等于某个阈值N，算法的运行时间在下限c1f(n)和上限 c2f(n)之间（0 < c1 ≤ c2），则称算法的时间复杂度是Θ(f(n))阶的。∀ ≥ N, c1f(n) ≤ T(n) ≤ c2f(n)则 T(n) = Θ(f(n))。
    4. T(n) = Θ(n^2) ，当且仅当T(n) = Ο(n^2) 并且T(n) = Ω(n^2)
4. 空间复杂度：算法的空间复杂性是以时间复杂性为上界的。这是因为在算法中每访问一次存储空间都是需要使用一定时间的，即使每次访问的都是不同的存储空间，空间的大小也不会超过基本操作次数常数倍，因此算法的空间复杂性是以时间复杂性为上界